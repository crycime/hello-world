// Generated by CoffeeScript 2.3.1
(function() {
  var Connector, MongoClient, _, debug, defaultLogger, inspect, mongodbUri;

  _ = require("underscore");

  debug = require("debug")("mongo-changestream-connector");

  mongodbUri = require("mongodb-uri");

  ({inspect} = require("util"));

  ({MongoClient} = require("mongodb"));

  ({defaultLogger} = require("./lib"));

  Connector = class Connector {
    constructor(args) {
      var error, host, log, port;
      this.start = this.start.bind(this);
      this.stop = this.stop.bind(this);
      this.changeStream = this.changeStream.bind(this);
      this.initReplset = this.initReplset.bind(this);
      ({log, options: this.options = {}, host, port, hosts: this.hosts, database: this.database, poolSize: this.poolSize, throwHappy: this.throwHappy, useMongoose: this.useMongoose} = args);
      this.log = log || defaultLogger("mongo-changestream-connector");
      this.mongo_or_mongoose = this.useMongoose ? "Mongoose" : "MongoDB";
      if (host && port) {
        this.hosts = [{host, port}];
      }
      if (!this.options.poolSize || this.options.poolSize < 5) {
        this.options.poolSize = 5;
      }
      if (!Array.isArray(this.hosts)) {
        throw new Error("hosts must be provided");
      }
      if (typeof this.database !== "string") {
        throw new Error("database must be provided");
      }
      if (this.useMongoose) {
        try {
          require("mongoose");
        } catch (error1) {
          error = error1;
          throw new Error("Mongoose must be installed!");
        }
      }
    }

    start(cb) {
      var mongoose, uri;
      uri = mongodbUri.format({hosts: this.hosts, database: this.database, options: this.options});
      if (this.useMongoose) {
        mongoose = require("mongoose");
        mongoose.Promise = global.Promise;
        this.mongooseConnection = mongoose.createConnection(uri);
        this.log.info(`Mongoose connecting to: ${uri}.`);
        return this.mongooseConnection.once("connected", () => {
          var logReadyState;
          this.log.info("Mongoose connected");
          logReadyState = (conn, event, error) => {
            var mssg;
            mssg = `mongo-changestream-connector connection \`${event}\``;
            if (conn.states) {
              mssg += ` during readystate ${conn.states[conn.readyState]}. `;
            }
            if (error) {
              mssg += ` Error: ${error}`;
            }
            this.log.warn(mssg);
            if (this.throwHappy && (event === "error" || event === "close")) {
              throw new Error(`Happily throwing: ${mssg}`);
            }
          };
          _.each(["close", "error", "reconnected", "disconnected"], (event) => {
            return this.mongooseConnection.on(event, logReadyState.bind(this, this.mongooseConnection, event));
          });
          this.models = this.mongooseConnection.models;
          return typeof cb === "function" ? cb() : void 0;
        });
      }
      this.log.info(`Mongo connecting to: ${uri}`);
      return MongoClient.connect(uri, (error, client) => {
        if (error) {
          return typeof cb === "function" ? cb(error) : void 0;
        }
        this.log.info("Mongo connected");
        this.mongoClient = client;
        this.db = client.db();
        return typeof cb === "function" ? cb() : void 0;
      });
    }

    stop(cb) {
      var connection;
      if (this.useMongoose) {
        if (this.mongooseConnection.readyState !== 1) {
          return cb();
        }
        connection = this.mongooseConnection;
      } else {
        if (!this.mongoClient.isConnected) {
          return cb();
        }
        connection = this.mongoClient;
      }
      if (this.throwHappy) {
        connection.removeAllListeners(["close"]);
      }
      return connection.close((error) => {
        if (error) {
          return typeof cb === "function" ? cb(error) : void 0;
        }
        this.log.info("Stopped Mongo Changestream Connector");
        return typeof cb === "function" ? cb() : void 0;
      });
    }

    changeStream(args) {
      var _onClose, _onError, coll, collection, model, name, onChange, onClose, onError, options, pipeline, watch;
      ({onChange, model, collection, pipeline = [], options = {}, onError, onClose} = args);
      name = this.useMongoose ? model : collection;
      if (typeof name !== "string") {
        throw new Error(`Must provide \`changeStream\` function with a \`${(this.useMongoose ? "model" : "collection")}\``);
      }
      if (typeof onChange !== "function") {
        throw new Error("Must provide `changeStream` function with an `onChange` handler.");
      }
      coll = this.useMongoose ? this.mongooseConnection.models[name] : this.db.collection(name);
      if (!coll) {
        // This can only happen in the case of Mongoose models
        throw new Error(`Model ${name} does not exist.`);
      }
      _onError = (error) => {
        if (onError) {
          return onError(error);
        }
        return this.log.error(`${this.mongo_or_mongoose} Change stream error for (${name}): ${error}`);
      };
      _onClose = () => {
        if (onClose) {
          return onClose();
        }
        return this.log.error(`${this.mongo_or_mongoose} Change stream closed for (${name}).`);
      };
      debug(`Setup a ${this.mongo_or_mongoose} change stream for \`${name}\`. Inspect pipeline:`, inspect(pipeline, {
        depth: 10
      }));
      watch = coll.watch(pipeline, options).on("change", onChange).on("error", _onError).on("close", _onClose);
      if (this.useMongoose) {
        return watch.driverChangeStream;
      } else {
        return watch;
      }
    }

    initReplset(cb) {
      var members, rsConfig, url;
      this.log.warn("Don't init replica set in production!");
      if (!this.options.replicaSet) {
        throw new Error("Need `replicaSet` option");
      }
      url = mongodbUri.format({hosts: this.hosts, database: this.database});
      members = _.map(this.hosts, function(host, i) {
        return {
          host: `${host.host}:${host.port}`,
          _id: i
        };
      });
      rsConfig = {
        _id: this.options.replicaSet,
        members: members
      };
      return MongoClient.connect(url, function(error, client) {
        var admin;
        if (error) {
          return cb(error);
        }
        admin = client.db("local").admin();
        return admin.replSetGetStatus(function(error, status) {
          if (!error) {
            return cb();
          }
          if (error.code !== 94) {
            return cb(error);
          }
          return admin.command({
            replSetInitiate: rsConfig
          }, function(error) {
            if (error) {
              return cb(error);
            }
            // Wait for initialisation to be done
            return setTimeout(function() {
              return cb();
            }, 10000);
          });
        });
      });
    }

  };

  module.exports = Connector;

}).call(this);
